---
layout: post
title:  "Collision Detection in 2D or 3D – Some Steps for Success"
date:   2022-09-17 15:28:52 -0700
categories: collision-detection
---
These are my personal opinions about recommended readings for collision detection in either 2D or 3D. This post is intended to act as a jumpstart in order to avoid endless swaths of outdated, poorly written, or otherwise incorrect information.

Some steps for success when writing your own collision detection.

1. Use the best resources. Collision detection success comes mostly from selecting the best and most well-known algorithms. A lot of articles and online resources give bad advice in the algorithms they pick, or obfuscate good algorithms with poor explanations. Go to [box2d.org](https://box2d.org/publications/) and look at Dirk Gregorius’s talks on the Separating Axis Test (2013) and Contact Creation (2015).
2. Collision detection is complicated, and the only way to keep it simple is to stick with very strict limitations, such as only AABBs. The moment rotations are added in even [OBB to OBB collision detection](https://web.archive.org/web/20200408025739/https://www.randygaul.net/2014/05/22/deriving-obb-to-obb-intersection-sat/) spikes in terms of complexity.
3. Look at [Box2D Lite](https://github.com/erincatto/box2d-lite) (not the full Box2D library, just the old 2006 demo) for a small C++ example for 2D OBBs. This is a good start before doing a 3D port.
4. GJK is a great algorithm to compute the closest points between two shapes, or to detect collision between two shapes. However, I personally recommend to *not* use EPA. Dirk’s 2015 lecture goes into some detail on specifically why EPA might be avoided. Please use [Erin’s lecture from 2010](https://box2d.org/publications/) to learn about GJK. He has great sample code that is readily portable to 3D. GJK is best used as a work-horse to implement higher level algorithms, like time of impact functions or Separating Axis Test functions.
5. Christer Ericson’s orange book [Real-Time Collision Detection](https://web.archive.org/web/20200408025739/https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323) is a great resource. It has fairly good example code, however it does contain a few small errors. Christer himself states the example code is not intended to be production ready. However, in practice most game studios I known of simply copy + paste his example code into production and then ship it, and it usually works quite well. A good book for beginners and professionals alike. The only real downside to this book is it doesn’t cover much beyond boolean collision detection, which is what Dirk’s resources are for.

I know it’s very tempting to search a bunch of different articles to try and find the resources that are the easiest to understand. However, other resources are going to more or less lead you into pitfalls. How do I know this? I’ve probably read any resource you might find online. I like collision detection and actively search and read things about the topic for fun. I’m sure there are some articles out there I haven’t read and would add to the recommended reading list, but the chances are quite low.

Just to be a little more convincing I will go ahead and list out some popular articles you will find if you go against my recommendation and start randomly searching online. Here are some resources I personally recommend *not* reading, with some short justifications on why they might be avoided.

1. wildbunny articles – The wildbunny articles mostly share outdated techniques, and are largely behind a pay wall. Not recommended as reading or as a purchase.
2. Game Physics by Ian Millington – This book is an ok resource for collision detection, but uses outdated techniques for collision resolution, and the example code itself uses poor software engineering practice, and the sample code in general is obfuscated. Not recommended as reading or as a purchase.
3. [David Eberly’s site and books](https://web.archive.org/web/20200408025739/https://www.geometrictools.com/) – David’s resources are quite robust and correct. In all cases where I’ve used his code it has both worked correctly and was very informative. However, David’s resources are very in-depth, often in ways that aren’t actually very relevant to whatever it is you specifically want to do at any given time. I recommend using David’s resources as a reference after some expertise have been built independently. His stuff is not helpful for beginners, and his example code is unnecessarily complicated in most cases, handling generality even when generality is likely unneeded.
4. [Metanet N Tutorial](https://web.archive.org/web/20200408025739/https://www.metanetsoftware.com/technique/tutorialA.html) – The N tutorial is actually an ok resource in terms of using a good algorithm without obfuscating it. It’s an ok introduction for 2D stuff, but is really inferior compared to the resources I linked above in my personal opinion, but maybe you'll find it a good resource.
5. [dynj4 GJK/EPA](https://web.archive.org/web/20200408025739/http://www.dyn4j.org/2010/05/epa-expanding-polytope-algorithm/) – This post actually contains pretty good information, and is a good way to learn about EPA in the 2D case. However, since I recommended not using EPA; In 3D EPA is expensive, very difficult to implement robustly, and usually requires an “incremental manifold” leading to artifacts during simulation.
6. [Casey Muratori’s video on GJK](https://web.archive.org/web/20200408025739/https://www.youtube.com/watch?v=Qupqu1xe7Io) – This video, although quite interesting, is not a great learning resource compared to Erin’s GJK slides from 2010. Also the underlying strategy Casey is advocating doesn’t actually work in practice. Go ahead and try skipping Voronoi regions in your code, run some basic tests, and it can be easily shown that Voronoi regions which might be logically skippable are not skippable in practice. My conclusion was that due to numeric approximation it is absolutely necessary to retest previously visited Voronoi regions. My best guess is Casey was not using GJK for physics simulation at the time, so he simply didn’t notice any problems (for example, if he was doing occlusion culling with the view frustum).
7. [My old tuts+ articles](https://web.archive.org/web/20200408025739/https://gamedevelopment.tutsplus.com/tutorials/how-to-create-a-custom-2d-physics-engine-the-basics-and-impulse-resolution--gamedev-6331) – This stuff is mostly just a rehash of things Erin and Dirk documented in their GDC talks. It can be ok for beginners and some 2D games, but is quite inferior compared to the recommended resources.

Stick to the top resources. If you’re confused when reading the top resources, that means you have valuable questions to ask and are not understanding something fundamentally important. Instead of searching around online through an endless sea of misinformation and poor articles, go to a forum like Gamedev.net and ask questions about the information in my list of recommended resources.
